# Документация:
Располагаете файл Validate.php с классом Validate в нужном месте вашего проекта.

Подключаете файл Validate.php. Например:
```php
include_once __DIR__ . '/../Components/Validate/Validate.php';
```

Доступные методы класса Validate:
  + errors(); - массив с возможными ошибками полученными в процессе валидации
  + passed(); - получение результата валидации
  + check($source, $arrayOfRules); - основной метод валидации данных в соответствии с правилами
    + $source – источник данных для валидации. Должен быть массив типа [ключ] => значение. Например глобальный массив POST(данные с формы), либо другой источник данных.
    + $arrayOfRules – правила валидации. Должен быть массив.

Доступные правила валидации:
  + min – минимальное кол-во символов
  + max – максимальное кол-во символов
  + required – обязательность заполнения данного поля
  + matches – проверка на совпадение данных одной и другой строки 
  + email – проверка на соответствие данных формату адреса эл.почты (example@site.com)

Пример использования компонента:

Создаем экземпляр объекта:
```php
$validation = new Validate();
```

Передаем в метод check класса Validate первым параметром глобальный массив POST, например, с переданными данными с пользовательской формы и вторым параметром наши правила валидации:
```php
$validation = $validation->check($_POST, [
            'username' => [
                'required' => true,      //поле в форме/ключ в массиве с данными с именем ‘username’ обязателен
                'min' => 2,	         //минимальное кол-во введенных символов поля ‘username’
                'max' => 15	         //максимальное кол-во введенных символов поля ‘username’
            ],
            'email' => [
                'required' => true,
                'email' => true	          //данные поля в форме/ключа в массиве должны быть в формате(example@site.com)
            ],
            'password' => [
                'required' => true,
                'min' => 6
            ],
            'password_again' => [
                'required' => true,
                'matches' => 'password'  //данные этого поля формы/ключа массива должны совпадать со значением поля/ключа массива ‘password’
            ]
]);
```
Названия ключей массива с правилами валидации (username, email, password, password_again или какие-то другие созданные вами) должны быть такими же, как и в атрибутах name тегов элементов - если это пользовательская форма, либо такими же как названия ключей того массива, который вы передаете с данными на валидацию.

Пример проверки результатов валидации:
```php
if ($validation->passed()) {        //Если валидация прошла успешно
            //code...
}
```

Привет вывода ошибок возникших в процессе валидации:
```php
if (!$validation->passed()) {      //Если валидация не пройдена и имеются ошибки
       echo '<div class="alert alert-danger"><ul>';
           foreach ($validation->errors() as $error) {
                 echo '<li>' . $error . '</li>';
            }
       echo '</ul></div>';
}
```


# Ход мыслей:

Здесь так же за основу был взят компонент Validate из второго модуля. Немного его конечно упростил.
Расковырял и разобрался с компонентом. Убрал в private функцию добавления возникших ошибок при валидации.
Тут впринципе на моем уровне развития я считаю, что как говорится «не добавить не убавить».
Хотя правда добавить и улучшить есть что.

Я сидел и размышлял, каким должен быть компонент валидации и как он должен работать.
Отправляем в класс массив POST с данными из формы, либо какие-то другие и из другого источника, но правда
должного вида, а то компонент не сработает, а так же правила валидации.
В классе, массивы с данными и правилами валидации «раздергиваются» и данные проверяются в соответствии с правилами
валидации и установленными параметрами. Если что-то не соответствует, то выходит ошибка, ну а если все хорошо, то работаем дальше.
Думаю что того функционала который есть в компоненте на начальном уровне должно хватить, ну а если что-то нужно еще,
то разработчик допишет, либо найдет другой компонент.
Я не профессиональный создатель инструментов, поэтому отдаю вам на суд то, что у меня есть))
Конечно, корявенько и далеко от идеала, я думаю, но для получения понимания как работает компонент впринципе, достаточно.

Если честно очень хочется работать с готовыми компонентами. Намного интреснее и увлекательнее.
Понял, что это конечно не совсем гуд делать себе инструменты и использовать их еще и в своих проектах.
Один инструмент равен практически целому проекту, а еще и после всего сам проект “пилить”, а таких инструментов
может быть десяток с лишним штук. Ох ох ох)))
